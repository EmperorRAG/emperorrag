# TSServer Trace Analyzer - Detailed Implementation Plan

This document provides a literal, step-by-step guide to implementing the TSServer Trace Analyzer tool. It includes the exact code snippets required for each file.

**Note**: This tool is designed to analyze **Trace Event** files (`trace.*.json`) generated by setting `"typescript.tsserver.trace": "verbose"`, NOT the standard text-based `tsserver.log`.

## Phase 1: Project Scaffolding

### Step 1.1: Generate Project

**Goal**: Initialize the project structure within the Nx monorepo.
**Why**: Using the Nx generator ensures the project is correctly registered in the workspace graph (`project.json`), sets up the correct root directories, and configures Vitest for testing automatically.

```bash
npx nx g @nx/vite:library tsserver-analyzer --directory=packages/tsserver-analyzer --importPath=@emperorrag/tsserver-analyzer --unitTestRunner=vitest --testEnvironment=node
```

### Step 1.2: Update Package Configuration

**Goal**: Configure the package metadata and dependencies.
**Why**: We need to define the `bin` property to tell Node.js which file to execute. We need `ts-node` for execution during development.

Modify `packages/tsserver-analyzer/package.json`:

```json
{
  "name": "@emperorrag/tsserver-analyzer",
  "version": "0.0.1",
  "bin": {
    "tsserver-analyzer": "./src/index.ts"
  },
  "dependencies": {
    "ts-node": "^10.9.1",
    "typescript": "^5.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0"
  }
}
```

### Step 1.3: Update TypeScript Configuration

**Goal**: Configure the TypeScript compiler for a Node.js environment.
**Why**: Ensure CommonJS output and Node.js type definitions are available.

Update `packages/tsserver-analyzer/tsconfig.lib.json`:

```json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2020",
    "types": ["node"],
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*.ts"],
  "exclude": ["vitest.config.ts", "src/**/*.spec.ts", "src/**/*.test.ts"]
}
```

## Phase 2: Type Definitions

### Step 2.1: Define Trace Interfaces

**Goal**: Create TypeScript interfaces for the Trace Event format.
**Why**: The input files are JSON arrays of trace events. We need to model the `ph` (phase), `ts` (timestamp), `dur` (duration), and `args` properties to correctly parse and analyze the data.

Create `packages/tsserver-analyzer/src/types.ts`:

```typescript
export interface TraceEvent {
    name: string;
    cat?: string;
    ph: string; // 'B' | 'E' | 'I' | 'X' | 'M'
    ts: number; // microseconds
    pid: number;
    tid: number;
    dur?: number; // microseconds (for 'X' events)
    args?: any;
}

export interface RequestArgs {
    seq: number;
    command: string;
}

export interface ResponseArgs {
    seq: number;
    command: string;
    success: boolean;
    request_seq?: number;
}

export interface PerformanceStat {
    count: number;
    totalDurationMicros: number;
    maxDurationMicros: number;
}

export interface SlowOperation {
    name: string;
    durationMs: number;
    timestamp: number;
    args?: any;
}
```

## Phase 3: Trace Parsing Logic

### Step 3.1: Implement Stream Parser

**Goal**: Create a function to parse the JSON trace file line-by-line.
**Why**: Trace files can be very large (hundreds of MBs). Loading the entire JSON array into memory will cause crashes. Since the format is typically one JSON object per line (comma-separated), we can stream the file, strip the trailing comma, and parse each line individually.

Create `packages/tsserver-analyzer/src/parser.ts`:

```typescript
import { TraceEvent } from './types';

export function parseTraceLine(line: string): TraceEvent | null {
    const trimmed = line.trim();
    // Skip start/end of array
    if (trimmed === '[' || trimmed === ']') return null;

    // Remove trailing comma if present
    const jsonString = trimmed.endsWith(',') ? trimmed.slice(0, -1) : trimmed;

    try {
        return JSON.parse(jsonString) as TraceEvent;
    } catch (e) {
        return null;
    }
}
```

## Phase 4: Analysis Engine

### Step 4.1: Implement Analyzer Class

**Goal**: Implement logic to track request latency and aggregate internal performance metrics.
**Why**:

1. **Request Latency**: `request` and `response` events are separate "Instant" (`ph: "I"`) events. We must match them by `seq` to calculate the round-trip time.
2. **Internal Perf**: The trace contains "Complete" (`ph: "X"`) events with a `dur` property (e.g., `parseJsonSourceFileConfigFileContent`). We can directly aggregate these to see where the server spends its time internally.

Create `packages/tsserver-analyzer/src/analyzer.ts`:

```typescript
import { TraceEvent, PerformanceStat, SlowOperation } from './types';

export class Analyzer {
    // Map request seq -> start timestamp (micros)
    private pendingRequests = new Map<number, number>();

    public commandStats = new Map<string, PerformanceStat>();
    public internalStats = new Map<string, PerformanceStat>();
    public slowOps: SlowOperation[] = [];

    processEvent(event: TraceEvent) {
        // 1. Handle Request/Response Pairs (Latency)
        if (event.name === 'request' && event.args?.seq !== undefined) {
            this.pendingRequests.set(event.args.seq, event.ts);
        }
        else if (event.name === 'response' && event.args?.seq !== undefined) {
            // Note: response args usually have 'seq' (its own) and 'request_seq' (the match)
            // But in some traces, the 'seq' in args IS the request seq.
            // We check 'request_seq' first, then fallback to 'seq' if it matches a pending request.
            const reqSeq = event.args.request_seq ?? event.args.seq;

            if (this.pendingRequests.has(reqSeq)) {
                const startTs = this.pendingRequests.get(reqSeq)!;
                const durationMicros = event.ts - startTs;
                const command = event.args.command || 'unknown';

                this.recordStat(this.commandStats, command, durationMicros);

                if (durationMicros > 500000) { // > 500ms
                    this.slowOps.push({
                        name: `Command: ${command}`,
                        durationMs: durationMicros / 1000,
                        timestamp: event.ts,
                        args: event.args
                    });
                }
                this.pendingRequests.delete(reqSeq);
            }
        }

        // 2. Handle Internal Trace Events (ph: 'X' has duration)
        if (event.ph === 'X' && event.dur !== undefined) {
            this.recordStat(this.internalStats, event.name, event.dur);

            if (event.dur > 500000) { // > 500ms
                this.slowOps.push({
                    name: `Internal: ${event.name}`,
                    durationMs: event.dur / 1000,
                    timestamp: event.ts,
                    args: event.args
                });
            }
        }
    }

    private recordStat(map: Map<string, PerformanceStat>, key: string, durationMicros: number) {
        const stat = map.get(key) || { count: 0, totalDurationMicros: 0, maxDurationMicros: 0 };
        stat.count++;
        stat.totalDurationMicros += durationMicros;
        stat.maxDurationMicros = Math.max(stat.maxDurationMicros, durationMicros);
        map.set(key, stat);
    }
}
```

## Phase 5: CLI Entry Point

### Step 5.1: Implement Main Script

**Goal**: Create the executable script.
**Why**: Ties the streaming file reader to the analyzer and prints the report.

Create `packages/tsserver-analyzer/src/index.ts`:

```typescript
import * as fs from 'fs';
import * as readline from 'readline';
import { parseTraceLine } from './parser';
import { Analyzer } from './analyzer';

async function main() {
    const logFilePath = process.argv[2];
    if (!logFilePath || !fs.existsSync(logFilePath)) {
        console.error('Please provide a valid path to trace.json');
        console.error('Usage: npx ts-node packages/tsserver-analyzer/src/index.ts <path-to-trace>');
        process.exit(1);
    }

    console.log(`Analyzing trace ${logFilePath}...`);

    const fileStream = fs.createReadStream(logFilePath);
    const rl = readline.createInterface({
        input: fileStream,
        crlfDelay: Infinity
    });

    const analyzer = new Analyzer();

    for await (const line of rl) {
        const event = parseTraceLine(line);
        if (event) {
            analyzer.processEvent(event);
        }
    }

    printReport(analyzer);
}

function printReport(analyzer: Analyzer) {
    console.log('\n=== TSServer Trace Analysis Report ===\n');

    console.log('--- Top 10 Slowest Operations (>500ms) ---');
    analyzer.slowOps
        .sort((a, b) => b.durationMs - a.durationMs)
        .slice(0, 10)
        .forEach(op => {
            console.log(`[${(op.timestamp/1000000).toFixed(2)}s] ${op.name}: ${op.durationMs.toFixed(2)}ms`);
            if (op.args) console.log(`    Args: ${JSON.stringify(op.args).slice(0, 100)}...`);
        });

    console.log('\n--- Command Statistics (Request/Response) ---');
    printStatsTable(analyzer.commandStats);

    console.log('\n--- Internal Compiler Performance ---');
    printStatsTable(analyzer.internalStats);
}

function printStatsTable(statsMap: Map<string, any>) {
    const tableData = Array.from(statsMap.entries())
        .map(([name, stat]) => ({
            Name: name,
            Count: stat.count,
            'Avg (ms)': (stat.totalDurationMicros / stat.count / 1000).toFixed(2),
            'Max (ms)': (stat.maxDurationMicros / 1000).toFixed(2),
            'Total (ms)': (stat.totalDurationMicros / 1000).toFixed(2)
        }))
        .sort((a, b) => parseFloat(b['Total (ms)']) - parseFloat(a['Total (ms)'])); // Sort by total time impact

    console.table(tableData);
}

main().catch(console.error);
```
